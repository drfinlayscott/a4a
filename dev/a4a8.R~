###############################################################################
# EJ(20111212)
# A4A assessment model 7 (same as 6 but fixed selectivities): 
#	Type: Separable SCAA 
#	Data:
#		catch-at-age
#		1 index of abundance, 
#	Error:
#		catch-at-age
#		abundance-at-age  
#	Fit: minimum squares	
#
#	Sa = linear up to full exploited age, 1 afterwards
#	Isel = q*sel
#	selq = sel0*exp(-beta*t) - exponential decay
#
# testing
###############################################################################

#==============================================================================
# Generic
#==============================================================================
setGeneric('a4a8', function(stk, idx, ...){standardGeneric('a4a8')})

#==============================================================================
# fobj
#==============================================================================

#------------------------------------------------------------------------------
# attempt ...
#------------------------------------------------------------------------------

fobj8 <- function(par, flqini, flcini, Cayobs, Iayobs, May, Cminage, Cmaxage, Cnages, Cnyrs, Cageidx, Cyrsidx, Iminage, Imaxage, Iageidx, Ichtidx) {
		aE <- par[1] # fully exploited age
		Fy <- exp(par[1+Cyrsidx])
		Ry <- exp(par[1+Cnyrs+Cyrsidx])
		lambda <- log(par[1+2*Cnyrs+1])
		q <- exp(-10*par[1+2*Cnyrs+2])

		Sa <- c(seq(0.05,1,length=aE-Cminage), rep(1,Cmaxage-aE+1))
		flcini[] <- Sa
		Sa <- flcini

		flqini[1,] <- Fy
		Fy <- flqini[rep(1,Cnages)]
		Fy <- FLCohort(Fy)@.Data[,,1,1,1,1, drop=TRUE] # <<<=== INEFICIENT
		
		flcini[1,1:(Cnages-1)] <- median(Ry)
		flcini[1,Cnages+Cyrsidx-1] <- Ry
		Ry <- flcini[rep(1,Cnages),]

		qa <- Iminage:Imaxage
		qa <- q*exp(-lambda*qa)
		flcini <- flcini[Iageidx, Ichtidx]
		flcini[] <- qa
		qa <- flcini

		Fay <- Fy*Sa 
		Zay <- Fay+May
		Zay[is.na(Zay)] <- 0 # trick to use cumsum which doesn't accept na.rm=T
		cumZ <- apply(Zay, 2, cumsum) # <<<=== INEFICIENT 	
		muay <- Fay/Zay*(1-exp(-Zay))
		Cayhat <- Ry[drop=T]*muay[drop=T]*exp(-cumZ)
		Iayhat <- qa[drop=T]*((Ry[drop=T]*exp(-cumZ))[Iageidx, Ichtidx])
		e1 <- (log(Cayobs[drop=T])-log(Cayhat))^2
		e1[is.infinite(e1)] <- NA
		e2 <- (log(Iayobs[drop=T])-log(Iayhat))^2
		e2[is.infinite(e2)] <- NA
		sum(e1, na.rm=T) + sum(e2, na.rm=T)  	
	}
#)

#==============================================================================
# a4a
#==============================================================================

setMethod("a4a8", c("FLStock", "FLIndex"), 
	function(stk, idx, hessian=FALSE) {
		# data
		cth <- catch.n(stk)
		flqini <- FLQuant(NA, dimnames=dimnames(cth))
		Cmaxage <- stk@range['max']
		Cminage <- stk@range['min'] 
		Cnages <- Cmaxage-Cminage+1
		Cnyrs <- stk@range['maxyear']-stk@range['minyear']+1
		Cageidx <- 1:Cnages
		Cyrsidx <- 1:Cnyrs
		Cayobs <- FLCohort(cth)
		flcini <- FLCohort(NA, dimnames=dimnames(Cayobs))
		May <- FLCohort(m(stk))
		Iayobs <- FLCohort(index(idx))
		Imaxage <- idx@range['max'] 
		Iminage <- idx@range['min']
		# recruitment indices make a mess with nbeta 0/0 so
		if(Imaxage==0 & Iminage==0) Imaxage <- Iminage <- 0.1 
		Inages <- idx@range['max']-idx@range['min']+1
		# To subset the catch matrix matching the index
		Cdnms <- dimnames(Cayobs)
		Idnms <- dimnames(Iayobs)
		Iageidx <- match(Idnms[[1]], Cdnms[[1]])
		Ichtidx <- match(Idnms[[2]], Cdnms[[2]])
		# starting values
		aE <- floor(Cnages/3)
		Fyini <- rep(0.5, Cnyrs)
		Ryini <- log(cth[1]/(0.1*(1-exp(-1)))) #M0=0.9 F0=0.1
		lambda <- 0.5
		# transformation for q y=-0.1*log(q); q=exp(-10*y)
		q <- exp(10e-10)
		par <- c(aE, Fyini, Ryini, lambda, q)
		# bounds - WARNING transformation on pars may require adjustement
		low <- c(floor(Cnages/3-1), sqrt(rep(1e-2, Cnyrs)), log(rep(min(Ryini)*0.1, Cnyrs)), exp(0.4), -0.1*log(1e-5))
		upp <- c(floor(Cnages/3+1), sqrt(rep(2, Cnyrs)), log(rep(max(Ryini)*10, Cnyrs)), exp(0.6), -0.1*log(1e-15))
		#ox <- optimx(par, fobj, flqini=flqini, flcini=flcini, Cayobs=Cayobs, Iayobs=Iayobs, May=May, Cnages=Cnages, Cnyrs=Cnyrs, Cageidx=Cageidx, Cyrsidx=Cyrsidx, Iageidx=Iageidx, Ichtidx=Ichtidx, parscale=rep(1,4), method='nlminb', lower=low, upper=upp, hessian=FALSE, itnmax=1000) 
		flcini=flcini@.Data[,,1,1,1,1, drop=TRUE]
		Cayobs=Cayobs@.Data[,,1,1,1,1, drop=TRUE]
		Iayobs=Iayobs@.Data[,,1,1,1,1, drop=TRUE]
		May=May@.Data[,,1,1,1,1, drop=TRUE]
		
		#nlminb(par, fobj7, hessian=FALSE, flqini=flqini, flcini=flcini, Cayobs=Cayobs, Iayobs=Iayobs, May=May, Cminage=Cminage, Cmaxage=Cmaxage, Cnages=Cnages, Cnyrs=Cnyrs, Cageidx=Cageidx, Cyrsidx=Cyrsidx, Imaxage=Imaxage, Iminage=Iminage, Iageidx=Iageidx, Ichtidx=Ichtidx, lower=low, upper=upp, control=list(iter.max=10000, eval.max=10000))
		DEoptim(fobj7, flqini=flqini, flcini=flcini, Cayobs=Cayobs, Iayobs=Iayobs, May=May, Cminage=Cminage, Cmaxage=Cmaxage, Cnages=Cnages, Cnyrs=Cnyrs, Cageidx=Cageidx, Cyrsidx=Cyrsidx, Imaxage=Imaxage, Iminage=Iminage, Iageidx=Iageidx, Ichtidx=Ichtidx, lower=low, upper=upp, control=DEoptim.control(strategy=6, c=0.4, trace=FALSE)) 
	}
)




# some utility functions
Data <- function(x) drop(x @ .Data)

iglogit <- function(x, min = 0, max = 1) 1/(1 + exp(-x)) * (max - min) + min
glogit <- function(p, min = 0, max = 1) {p <- (p - min) / (max - min); log(p / (1-p))}

time <- function() proc.time()

# convert model parameters from vector to list 
# and convert supports
get_stk_pars <-
function(par, data_summaries)
{
  with(data_summaries,
  list(
    aE     = iglogit(par[1], min = Cminage, max = Cmaxage), # fully exploited age
 	  Fy     = exp(par[1+Cyrsidx]),
	  Ry     = exp(par[1+Cnyrs+Cyrsidx]),
	  lambda = exp(par[1+2*Cnyrs+1]),
	  logq   = par[1+2*Cnyrs+2]
  ))
}

# get the fishery and survey selection functions
get_stk_funs <-
function(pars, data_summaries)
{
  with(data_summaries,
  list(
    S = function(a) ifelse(a < pars $ aE, 0.05 + 0.95 * (a - Cminage)/(pars $ aE - Cminage), 1),
    q = function(a) exp(pars $ logq - pars $ lambda * a)
  ))
}

# calculate useful data summaries
get_data_summaries <-
function(obs)
{
  out <-
  with(obs,
  list(
    Iages = as.numeric(rownames(index)),
    Iyrs = as.numeric(colnames(index)),
    Cages = as.numeric(rownames(catch)),
    Cyrs = as.numeric(colnames(catch))
  )) 
  within(out,
  {
    Iminage = min(Iages)
    Imaxage = max(Iages)
    Inyrs = length(Iyrs)
    Inages = length(Iages)
    Cminage = min(Cages)
    Cmaxage = max(Cages)
    Cnyrs = length(Cyrs)
    Cnages = length(Cages)
    Cyrsidx = 1:length(Cyrs)
    CinIages = Cages %in% Iages
    CinIyrs = Cyrs %in% Iyrs
  })
}

# Predict population
predict_pop <-
function(par, data_summaries, M, full = FALSE)
{
  stk_pars <- get_stk_pars(par, data_summaries)
  stk_funs <- get_stk_funs(stk_pars, data_summaries)

  S <- stk_funs $ S(data_summaries $ Cages)
  F <- S %*% t(stk_pars $ Fy)
  qa <- stk_funs $ q(data_summaries $ Iages)
  q <- qa %*% t(rep(1, data_summaries $ Inyrs))
  Z <- F + M

  # cohortify Z
  Zc <- 
    do.call(rbind, 
      lapply(1:nrow(Z), 
        function(i, nr) c(rep(NA,nr-i), Z[i,], rep(NA,i-1)), 
        nr = nrow(Z)))
  Zc <- Zc[,-(1:(nrow(Z) - 1))]      

  # fill out N with recruits
  Nc <- matrix(stk_pars $ Ry, nrow(Zc), ncol(Zc), byrow = TRUE)      
  # do cumulative Zs down cohorts
  Zc.cum <- apply(Zc, 2, function(x) c(0, cumsum(x[-length(x)])))
  # generate population
  Nc <- Nc * exp(-Zc.cum)

  # un-cohortify N
  N <-
    do.call(rbind,
      lapply(1:nrow(Nc), 
        function(i, nr) c(rep(NA, i-1), Nc[i,], rep(NA, nr-i+1)), 
        nr = nrow(Nc)))
  N <- N[,-(2:nrow(N) + ncol(F))]

  catch <- F / (F + M) * (1 - exp(-Z)) * N[,-ncol(N)]
  index <-  q * with(data_summaries, N[CinIages, c(CinIyrs, TRUE)])

  if (full)
    list(catch = catch, index = index, 
         N = N, F = F, S = S, qa = qa, 
         funs = stk_funs, par = stk_pars)
  else
    list(catch = catch, index = index)
}


# the negative log likelihood
neg.llik <-
function(par, data_summaries, M, obs)
{

  pred <- predict_pop(par[-(1:2)], data_summaries, M)
  
  # add smallest observed catch for zero catch
  obs $ catch[obs $ catch == 0] <- min(obs $ catch[obs $ catch > 0], na.rm = TRUE)
  
  llik.catch <- sum(dnorm(log(obs $ catch),  log(pred $ catch), exp(par[1]), log = TRUE), na.rm = TRUE)
  llik.index <- sum(dnorm(log(obs $ index),  log(pred $ index), exp(par[2]), log = TRUE), na.rm = TRUE)
   
  -1 * (llik.catch + llik.index)
}


# the main fitting function/algorithm
SCA.fit <-
function(obs, M, trace = 10)
{
  time0 <- time()
  # get starting values (improve this along the lines of EJ code)
  par.init <- rep(0, 107)

  data_summaries <- get_data_summaries(obs)

  neg.llik(par.init, data_summaries, M, obs)

  opt <- nlminb(par.init, neg.llik, 
                data_summaries = data_summaries, M = M, obs = obs, 
                control = list(trace = trace))

  out <- predict_pop(opt $ par[-(1:2)], data_summaries, M, full = TRUE)
  out $ par $ sigma <- exp(opt $ par[1:2])
  out $ opt <- opt
  out $ llik <- -1 * opt $ objective
  out $ aic <- -2 * out $ llik + 2 * length(par.init)
  out $ ellapsed <- time() - time0
  
  out
}



