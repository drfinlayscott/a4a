


# the main fitting function/algorithm
SCA.fit <-
function(obs, M, trace = 10)
{
  time0 <- time()
  # get starting values (improve this along the lines of EJ code)
  par.init <- rep(0, 107)

  data_summaries <- get_data_summaries(obs)

  neg.llik(par.init, data_summaries, M, obs)

  opt <- nlminb(par.init, neg.llik, 
                data_summaries = data_summaries, M = M, obs = obs, 
                control = list(trace = trace))

  out <- predict_pop(opt $ par[-(1:2)], data_summaries, M, full = TRUE)
  out $ par $ sigma <- exp(opt $ par[1:2])
  out $ opt <- opt
  out $ llik <- -1 * opt $ objective
  out $ aic <- -2 * out $ llik + 2 * length(par.init)
  out $ ellapsed <- time() - time0
  
  out
}



# some utility functions
Data <- function(x) drop(x @ .Data)

iglogit <- function(x, min = 0, max = 1) 1/(1 + exp(-x)) * (max - min) + min
glogit <- function(p, min = 0, max = 1) {p <- (p - min) / (max - min); log(p / (1-p))}

time <- function() proc.time()

# convert model parameters from vector to list 
# and convert supports
get_stk_pars <-
function(par, data_summaries)
{
  with(data_summaries,
  list(
    aE     = iglogit(par[1], min = Cminage, max = Cmaxage), # fully exploited age
 	  Fy     = exp(par[1+Cyrsidx]),
	  Ry     = exp(par[1+Cnyrs+Cyrsidx]),
	  lambda = exp(par[1+2*Cnyrs+1]),
	  logq   = par[1+2*Cnyrs+2]
  ))
}

# get the fishery and survey selection functions
get_stk_funs <-
function(pars, data_summaries)
{
  with(data_summaries,
  list(
    S = function(a) ifelse(a < pars $ aE, 0.05 + 0.95 * (a - Cminage)/(pars $ aE - Cminage), 1),
    q = function(a) exp(pars $ logq - pars $ lambda * a)
  ))
}

# calculate useful data summaries
get_data_summaries <-
function(obs)
{
  out <-
  with(obs,
  list(
    Iages = as.numeric(rownames(index)),
    Iyrs = as.numeric(colnames(index)),
    Cages = as.numeric(rownames(catch)),
    Cyrs = as.numeric(colnames(catch))
  )) 
  within(out,
  {
    Iminage = min(Iages)
    Imaxage = max(Iages)
    Inyrs = length(Iyrs)
    Inages = length(Iages)
    Cminage = min(Cages)
    Cmaxage = max(Cages)
    Cnyrs = length(Cyrs)
    Cnages = length(Cages)
    Cyrsidx = 1:length(Cyrs)
    CinIages = Cages %in% Iages
    CinIyrs = Cyrs %in% Iyrs
  })
}

# Predict population
predict_pop <-
function(par, data_summaries, M, full = FALSE)
{
  stk_pars <- get_stk_pars(par, data_summaries)
  stk_funs <- get_stk_funs(stk_pars, data_summaries)

  S <- stk_funs $ S(data_summaries $ Cages)
  F <- S %*% t(stk_pars $ Fy)
  qa <- stk_funs $ q(data_summaries $ Iages)
  q <- qa %*% t(rep(1, data_summaries $ Inyrs))
  Z <- F + M

  # cohortify Z
  Zc <- 
    do.call(rbind, 
      lapply(1:nrow(Z), 
        function(i, nr) c(rep(NA,nr-i), Z[i,], rep(NA,i-1)), 
        nr = nrow(Z)))
  Zc <- Zc[,-(1:(nrow(Z) - 1))]      

  # fill out N with recruits
  Nc <- matrix(stk_pars $ Ry, nrow(Zc), ncol(Zc), byrow = TRUE)      
  # do cumulative Zs down cohorts
  Zc.cum <- apply(Zc, 2, function(x) c(0, cumsum(x[-length(x)])))
  # generate population
  Nc <- Nc * exp(-Zc.cum)

  # un-cohortify N
  N <-
    do.call(rbind,
      lapply(1:nrow(Nc), 
        function(i, nr) c(rep(NA, i-1), Nc[i,], rep(NA, nr-i+1)), 
        nr = nrow(Nc)))
  N <- N[,-(2:nrow(N) + ncol(F))]

  catch <- F / (F + M) * (1 - exp(-Z)) * N[,-ncol(N)]
  index <-  q * with(data_summaries, N[CinIages, c(CinIyrs, TRUE)])

  if (full)
    list(catch = catch, index = index, 
         N = N, F = F, S = S, qa = qa, 
         funs = stk_funs, par = stk_pars)
  else
    list(catch = catch, index = index)
}


# the negative log likelihood
neg.llik <-
function(par, data_summaries, M, obs)
{

  pred <- predict_pop(par[-(1:2)], data_summaries, M)
  
  # add smallest observed catch for zero catch
  obs $ catch[obs $ catch == 0] <- min(obs $ catch[obs $ catch > 0], na.rm = TRUE)
  
  llik.catch <- sum(dnorm(log(obs $ catch),  log(pred $ catch), exp(par[1]), log = TRUE), na.rm = TRUE)
  llik.index <- sum(dnorm(log(obs $ index),  log(pred $ index), exp(par[2]), log = TRUE), na.rm = TRUE)
   
  -1 * (llik.catch + llik.index)
}



